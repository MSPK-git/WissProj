import puppeteer, { ElementHandle } from "puppeteer-core";

/**
 * The functions in this section are extracted from an exported puppeteer script auto-generated by Chrome.
 */
// export async function waitForSelectors(
//     selectors: string[][],
//     frame: puppeteer.Page,
//     options: puppeteer.WaitForSelectorOptions | undefined,
// ): Promise<ElementHandle<Element>> {
//     for (const selector of selectors) {
//         try {
//             return await waitForSelector(selector, frame, options);
//         } catch (err) {
//             console.error(err);
//         }
//     }
//     throw new Error("Could not find element for selectors: " + JSON.stringify(selectors));
// }

// export async function waitForSelector(
//     selector: string[],
//     frame: puppeteer.Page,
//     options: puppeteer.WaitForSelectorOptions | undefined,
// ): Promise<ElementHandle<Element>> {
//     if (!Array.isArray(selector)) {
//         selector = [selector];
//     }
//     if (!selector.length) {
//         throw new Error("Empty selector provided to waitForSelector");
//     }
//     let element = null;
//     for (let i = 0; i < selector.length; i++) {
//         const part = selector[i];
//         if (element) {
//             element = await element.waitForSelector(part, options);
//         } else {
//             element = await frame.waitForSelector(part, options);
//         }
//         if (!element) {
//             throw new Error("Could not find element: " + selector.join(">>"));
//         }
//         if (i < selector.length - 1) {
//             element = (
//                 await element.evaluateHandle((el) => (el.shadowRoot ? el.shadowRoot : el))
//             ).asElement();
//         }
//     }
//     if (!element) {
//         throw new Error("Could not find element: " + selector.join("|"));
//     }
//     return element as ElementHandle<Element>;
// }
export async function scrollIntoViewIfNeeded(element: ElementHandle<Element>, timeout: number) {
    await waitForConnected(element, timeout);
    const isInViewport = await element.isIntersectingViewport({ threshold: 0 });
    if (isInViewport) {
        return;
    }
    await element.evaluate((element) => {
        element.scrollIntoView({
            block: "center",
            inline: "center",
            behavior: "auto",
        });
    });
    await waitForInViewport(element, timeout);
}

export async function waitForConnected(element: ElementHandle<Element>, timeout: number) {
    await waitForFunction(async () => {
        return await element.getProperty("isConnected");
    }, timeout);
}

export async function waitForInViewport(element: ElementHandle<Element>, timeout: number) {
    await waitForFunction(async () => {
        return await element.isIntersectingViewport({ threshold: 0 });
    }, timeout);
}

export async function waitForFunction(fn: () => Promise<unknown>, timeout: number) {
    let isActive = true;
    setTimeout(() => {
        isActive = false;
    }, timeout);
    while (isActive) {
        const result = await fn();
        if (result) {
            return;
        }
        await new Promise((resolve) => setTimeout(resolve, 100));
    }
    throw new Error("Timed out");
}

/**
 * The following functions are written by us.
 */



export async function mouseWheel(targetPage: puppeteer.Page, amount: number) {
    await targetPage.mouse.wheel({ deltaY: amount });
}

export async function holdAndDragMouse(
    targetPage: puppeteer.Page,
    x: number,
    y: number,
    timeout: number,
) {
    await targetPage.mouse.down();
    await targetPage.mouse.move(x, y);
    await targetPage.mouse.up();
    await targetPage.waitForTimeout(timeout);
}
